const { app, BrowserWindow, globalShortcut, ipcMain, screen, desktopCapturer, clipboard } = require('electron');
const path = require('path');
const localShortcut = require('electron-localshortcut');
const screenshot = require('screenshot-desktop');
const sharp = require('sharp');
const fs = require('fs');

// Load environment variables
require('dotenv').config();

// Import services
const AIService = require('./services/AIService');
const AudioService = require('./services/AudioService');
const StealthService = require('./services/StealthService');
const ContextService = require('./services/ContextService');

class MockMateApp {
    constructor() {
        this.controlWindow = null;
        this.responseWindow = null;
        this.isHidden = false;
        this.currentPosition = { x: 0, y: 0 };
        this.currentSize = { width: 1200, height: 400 };
        this.isInitialized = false;
        
        // Services
        this.aiService = new AIService();
        this.audioService = new AudioService();
        this.stealthService = new StealthService();
        this.contextService = new ContextService();
        
        // App state
        this.appState = {
            isListening: false,
            isMicEnabled: false,
            isSystemSoundEnabled: false,
            isAIWorking: false,
            currentQuestion: '',
            companyName: '',
            jobDescription: '',
            selectedModel: 'gemini-pro'
        };
    }

    async initialize() {
        await app.whenReady();
        
        // Enable stealth mode
        await this.stealthService.enableStealthMode();
        
        // Create windows
        this.createControlWindow();
        this.createResponseWindow();
        
        // Setup global shortcuts
        this.setupGlobalShortcuts();
        
        // Setup IPC handlers
        this.setupIPCHandlers();
        
        // Position windows
        this.positionWindows();
        
        this.isInitialized = true;
        console.log('MockMate AI initialized with stealth capabilities');
    }

    createControlWindow() {
        const { width, height } = screen.getPrimaryDisplay().workAreaSize;
        
        this.controlWindow = new BrowserWindow({
            width: this.currentSize.width,
            height: this.currentSize.height,
            x: Math.floor((width - this.currentSize.width) / 2),
            y: 50,
            frame: false,
            transparent: true,
            alwaysOnTop: true,
            skipTaskbar: true,
            resizable: false,
            movable: true,
            webPreferences: {
                nodeIntegration: true,
                contextIsolation: false,
                enableRemoteModule: true,
                backgroundThrottling: false
            },
            show: false
        });

        // Load the control panel
        this.controlWindow.loadFile(path.join(__dirname, '../mockmate-control-panel.html'));
        
        // Hide from Alt+Tab and taskbar completely
        this.stealthService.hideFromTaskbar(this.controlWindow);
        
        // Window events
        this.controlWindow.once('ready-to-show', () => {
            this.controlWindow.show();
            this.controlWindow.setAlwaysOnTop(true, 'screen-saver', 1);
        });

        this.controlWindow.on('closed', () => {
            this.controlWindow = null;
        });

        // Make window click-through when needed
        this.controlWindow.setIgnoreMouseEvents(false);
    }

    createResponseWindow() {
        const { width, height } = screen.getPrimaryDisplay().workAreaSize;
        
        this.responseWindow = new BrowserWindow({
            width: this.currentSize.width,
            height: 600,
            x: Math.floor((width - this.currentSize.width) / 2),
            y: this.currentSize.height + 60,
            frame: false,
            transparent: true,
            alwaysOnTop: true,
            skipTaskbar: true,
            resizable: false,
            movable: true,
            webPreferences: {
                nodeIntegration: true,
                contextIsolation: false,
                enableRemoteModule: true,
                backgroundThrottling: false
            },
            show: false
        });

        // Load the response window
        this.responseWindow.loadFile(path.join(__dirname, '../mockmate-response-window.html'));
        
        // Hide from Alt+Tab and taskbar completely
        this.stealthService.hideFromTaskbar(this.responseWindow);
        
        // Window events
        this.responseWindow.once('ready-to-show', () => {
            this.responseWindow.show();
            this.responseWindow.setAlwaysOnTop(true, 'screen-saver', 1);
        });

        this.responseWindow.on('closed', () => {
            this.responseWindow = null;
        });
    }

    setupGlobalShortcuts() {
        // System Sound Enable/Disable: Shift+S
        globalShortcut.register('Shift+S', () => {
            this.toggleSystemSound();
        });

        // AI Answer Trigger: Ctrl+Z
        globalShortcut.register('CommandOrControl+Z', () => {
            this.triggerAIAnswer();
        });

        // Window Hide/Show: Ctrl+X
        globalShortcut.register('CommandOrControl+X', () => {
            this.toggleWindowVisibility();
        });

        // Mic Enable/Disable: Ctrl+Q
        globalShortcut.register('CommandOrControl+Q', () => {
            this.toggleMicrophone();
        });

        // Analyze Screen: Ctrl+A
        globalShortcut.register('CommandOrControl+A', () => {
            this.analyzeScreen();
        });

        // Manual Question Entry: Ctrl+I
        globalShortcut.register('CommandOrControl+I', () => {
            this.focusQuestionInput();
        });

        // Clear Listening Area: Ctrl+C
        globalShortcut.register('CommandOrControl+C', () => {
            this.clearTranscription();
        });

        // Move Left: Ctrl+>
        globalShortcut.register('CommandOrControl+numadd', () => {
            this.moveWindowLeft();
        });

        // Move Right: Ctrl+<
        globalShortcut.register('CommandOrControl+numsub', () => {
            this.moveWindowRight();
        });

        // Decrease Size: Ctrl+-
        globalShortcut.register('CommandOrControl+-', () => {
            this.decreaseWindowSize();
        });

        // Increase Size: Ctrl++
        globalShortcut.register('CommandOrControl+=', () => {
            this.increaseWindowSize();
        });
    }

    setupIPCHandlers() {
        // Audio events
        ipcMain.handle('toggle-microphone', () => {
            return this.toggleMicrophone();
        });

        ipcMain.handle('toggle-system-sound', () => {
            return this.toggleSystemSound();
        });

        // AI events
        ipcMain.handle('generate-answer', async (event, question) => {
            return await this.generateAIAnswer(question);
        });

        ipcMain.handle('analyze-screen', async () => {
            return await this.analyzeScreen();
        });

        // Window events
        ipcMain.handle('hide-windows', () => {
            this.toggleWindowVisibility();
        });

        // State events
        ipcMain.handle('get-app-state', () => {
            return this.appState;
        });

        ipcMain.handle('update-app-state', (event, newState) => {
            this.appState = { ...this.appState, ...newState };
            this.broadcastStateUpdate();
        });

        // Model selection
        ipcMain.handle('set-ai-model', (event, model) => {
            this.appState.selectedModel = model;
            this.aiService.setModel(model);
        });

        // File processing
        ipcMain.handle('upload-resume', async (event, filePath) => {
            return await this.processResumeFile(filePath);
        });

        ipcMain.handle('upload-job-description', async (event, filePath) => {
            return await this.processJobDescriptionFile(filePath);
        });

        // Context management
        ipcMain.handle('get-context-summary', () => {
            return this.contextService.getContextSummary();
        });

        ipcMain.handle('clear-context', () => {
            this.contextService.clearContext();
        });

        ipcMain.handle('update-interview-details', (event, details) => {
            this.contextService.updateInterviewDetails(details);
            // Update app state with interview details
            this.appState.companyName = details.company || this.appState.companyName;
        });
    }

    async toggleMicrophone() {
        try {
            this.appState.isMicEnabled = !this.appState.isMicEnabled;
            
            if (this.appState.isMicEnabled) {
                await this.audioService.startMicrophoneRecording((transcription) => {
                    this.handleTranscription(transcription);
                });
            } else {
                this.audioService.stopMicrophoneRecording();
            }
            
            this.updateWorkingStatus();
            this.broadcastStateUpdate();
            return this.appState.isMicEnabled;
        } catch (error) {
            console.error('Error toggling microphone:', error);
            return false;
        }
    }

    async toggleSystemSound() {
        try {
            this.appState.isSystemSoundEnabled = !this.appState.isSystemSoundEnabled;
            
            if (this.appState.isSystemSoundEnabled) {
                await this.audioService.startSystemAudioCapture((transcription) => {
                    this.handleTranscription(transcription);
                });
            } else {
                this.audioService.stopSystemAudioCapture();
            }
            
            this.updateWorkingStatus();
            this.broadcastStateUpdate();
            return this.appState.isSystemSoundEnabled;
        } catch (error) {
            console.error('Error toggling system sound:', error);
            return false;
        }
    }

    handleTranscription(transcription) {
        this.appState.currentQuestion = transcription;
        this.broadcastTranscription(transcription);
    }

    async generateAIAnswer(question = null) {
        try {
            this.appState.isAIWorking = true;
            this.updateWorkingStatus();
            
            const queryText = question || this.appState.currentQuestion;
            if (!queryText) {
                throw new Error('No question to process');
            }

            // Build context using ContextService for precise responses
            const contextPrompt = this.contextService.buildContextForAI(queryText);
            
            const context = {
                company: this.appState.companyName || this.contextService.getContextSummary().company,
                jobDescription: this.appState.jobDescription,
                question: contextPrompt, // Use enhanced context prompt
                relevantSkills: this.contextService.getRelevantSkills(queryText),
                relevantExperience: this.contextService.getRelevantExperience(queryText)
            };

            const response = await this.aiService.generateResponse(context);
            
            // Send response to response window
            if (this.responseWindow) {
                this.responseWindow.webContents.send('display-response', response);
            }

            this.appState.isAIWorking = false;
            this.updateWorkingStatus();
            
            return response;
        } catch (error) {
            console.error('Error generating AI answer:', error);
            this.appState.isAIWorking = false;
            this.updateWorkingStatus();
            throw error;
        }
    }

    async analyzeScreen() {
        try {
            this.appState.isAIWorking = true;
            this.updateWorkingStatus();

            // Capture screen
            const screenshot = await this.captureScreen();
            
            // Use OCR to extract text
            const extractedText = await this.aiService.performOCR(screenshot);
            
            // Find question in the extracted text
            const question = await this.aiService.extractQuestion(extractedText);
            
            if (question) {
                this.appState.currentQuestion = question;
                this.broadcastTranscription(question);
                
                // Auto-generate answer
                await this.generateAIAnswer(question);
            }

            this.appState.isAIWorking = false;
            this.updateWorkingStatus();
            
            return question;
        } catch (error) {
            console.error('Error analyzing screen:', error);
            this.appState.isAIWorking = false;
            this.updateWorkingStatus();
            throw error;
        }
    }

    async captureScreen() {
        try {
            const sources = await desktopCapturer.getSources({
                types: ['screen'],
                thumbnailSize: { width: 1920, height: 1080 }
            });

            if (sources.length > 0) {
                const screenshot = sources[0].thumbnail.toPNG();
                return screenshot;
            }
            throw new Error('No screen sources available');
        } catch (error) {
            console.error('Error capturing screen:', error);
            throw error;
        }
    }

    async triggerAIAnswer() {
        await this.generateAIAnswer();
    }

    toggleWindowVisibility() {
        this.isHidden = !this.isHidden;
        
        if (this.isHidden) {
            if (this.controlWindow) this.controlWindow.hide();
            if (this.responseWindow) this.responseWindow.hide();
        } else {
            if (this.controlWindow) {
                this.controlWindow.show();
                this.controlWindow.setAlwaysOnTop(true, 'screen-saver', 1);
            }
            if (this.responseWindow) {
                this.responseWindow.show();
                this.responseWindow.setAlwaysOnTop(true, 'screen-saver', 1);
            }
        }
    }

    focusQuestionInput() {
        if (this.controlWindow) {
            this.controlWindow.webContents.send('focus-question-input');
        }
    }

    clearTranscription() {
        this.appState.currentQuestion = '';
        if (this.controlWindow) {
            this.controlWindow.webContents.send('clear-transcription');
        }
    }

    moveWindowLeft() {
        const currentPos = this.controlWindow.getPosition();
        this.controlWindow.setPosition(currentPos[0] - 50, currentPos[1]);
        if (this.responseWindow) {
            const respPos = this.responseWindow.getPosition();
            this.responseWindow.setPosition(respPos[0] - 50, respPos[1]);
        }
    }

    moveWindowRight() {
        const currentPos = this.controlWindow.getPosition();
        this.controlWindow.setPosition(currentPos[0] + 50, currentPos[1]);
        if (this.responseWindow) {
            const respPos = this.responseWindow.getPosition();
            this.responseWindow.setPosition(respPos[0] + 50, respPos[1]);
        }
    }

    decreaseWindowSize() {
        this.currentSize.width = Math.max(800, this.currentSize.width - 100);
        this.controlWindow.setSize(this.currentSize.width, this.currentSize.height);
        if (this.responseWindow) {
            this.responseWindow.setSize(this.currentSize.width, 600);
        }
    }

    increaseWindowSize() {
        this.currentSize.width = Math.min(1600, this.currentSize.width + 100);
        this.controlWindow.setSize(this.currentSize.width, this.currentSize.height);
        if (this.responseWindow) {
            this.responseWindow.setSize(this.currentSize.width, 600);
        }
    }

    positionWindows() {
        const { width, height } = screen.getPrimaryDisplay().workAreaSize;
        const x = Math.floor((width - this.currentSize.width) / 2);
        
        if (this.controlWindow) {
            this.controlWindow.setPosition(x, 50);
        }
        
        if (this.responseWindow) {
            this.responseWindow.setPosition(x, this.currentSize.height + 60);
        }
    }

    updateWorkingStatus() {
        const isWorking = this.appState.isAIWorking || 
                         this.appState.isMicEnabled || 
                         this.appState.isSystemSoundEnabled;
        
        if (this.controlWindow) {
            this.controlWindow.webContents.send('update-working-status', isWorking);
        }
    }

    broadcastStateUpdate() {
        if (this.controlWindow) {
            this.controlWindow.webContents.send('state-update', this.appState);
        }
        if (this.responseWindow) {
            this.responseWindow.webContents.send('state-update', this.appState);
        }
    }

    broadcastTranscription(text) {
        if (this.controlWindow) {
            this.controlWindow.webContents.send('transcription-update', text);
        }
    }

    async processResumeFile(filePath) {
        try {
            const resumeData = await this.contextService.processResumeFile(filePath);
            console.log('Resume processed successfully:', resumeData.fileName);
            return {
                success: true,
                data: resumeData,
                message: `Resume "${resumeData.fileName}" processed successfully`
            };
        } catch (error) {
            console.error('Error processing resume:', error);
            return {
                success: false,
                error: error.message,
                message: 'Failed to process resume file'
            };
        }
    }

    async processJobDescriptionFile(filePath) {
        try {
            const jobData = await this.contextService.processJobDescriptionFile(filePath);
            console.log('Job description processed successfully:', jobData.fileName);
            
            // Update app state with job info
            this.appState.companyName = jobData.company || this.appState.companyName;
            this.appState.jobDescription = jobData.text || this.appState.jobDescription;
            
            return {
                success: true,
                data: jobData,
                message: `Job description "${jobData.fileName}" processed successfully`
            };
        } catch (error) {
            console.error('Error processing job description:', error);
            return {
                success: false,
                error: error.message,
                message: 'Failed to process job description file'
            };
        }
    }
}

// Application lifecycle
const mockMateApp = new MockMateApp();

app.whenReady().then(() => {
    mockMateApp.initialize();
});

app.on('window-all-closed', () => {
    if (process.platform !== 'darwin') {
        app.quit();
    }
});

app.on('activate', () => {
    if (!mockMateApp.isInitialized) {
        mockMateApp.initialize();
    }
});

app.on('will-quit', () => {
    globalShortcut.unregisterAll();
});

// Handle app being hidden from screen sharing
app.on('browser-window-created', (event, window) => {
    mockMateApp.stealthService.hideFromScreenShare(window);
});

module.exports = MockMateApp;
module.exports = { MockMateAPI };

